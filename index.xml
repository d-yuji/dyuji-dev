<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>dyuji.dev</title><link>https://dyuji.dev/</link><description>Recent content on dyuji.dev</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Tue, 28 Dec 2021 23:46:09 +0900</lastBuildDate><atom:link href="https://dyuji.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Jmeter Hash</title><link>https://dyuji.dev/blog/memo/jmeter_hash/</link><pubDate>Tue, 28 Dec 2021 23:46:09 +0900</pubDate><guid>https://dyuji.dev/blog/memo/jmeter_hash/</guid><description> JMeterのシナリオで変数をHash化する時はBeanShell PreProcesserを使う import java.security.MessageDigest; String token = vars.get(&amp;#34;token&amp;#34;); // Jmeterの変数を取得 String api_key = &amp;#34;hogehuga&amp;#34;; String encrypt_str = token+api_key; MessageDigest digest = MessageDigest.getInstance(&amp;#34;SHA-256&amp;#34;); byte[] hash = digest.digest(encrypt_str.getBytes()); StringBuilder sb = new StringBuilder(2*hash.length); for (byte b: hash) { String hexStr = Integer.toHexString(b).replaceAll(&amp;#34;ffffff&amp;#34;,&amp;#34;&amp;#34;); String hex = (hexStr.length() == 1) ? &amp;#34;0&amp;#34; + hexStr : hexStr; sb.append(hex); } String newVariable = sb.toString(); var.put(&amp;#34;ENCRYPTED_TOKEN&amp;#34;,newVariable); // Jmeterの変数にセット</description></item><item><title>5G</title><link>https://dyuji.dev/blog/books/5g/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/books/5g/</guid><description>5G 大容量・低遅延・多接続のしくみ 感想：5Gの普及でより情報量の多いコンテンツの配信等ができるようになるのは間違いない。今まで有線のPCでしか出来なかったことがスマホ端末でもできるようになっていくと思われるが、消費者的に一番恩恵を受けるのはゲームの分野かと思った。</description></item><item><title>dockerからlocalhostに接続</title><link>https://dyuji.dev/blog/memo/docker_localhost/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/memo/docker_localhost/</guid><description>Docker for Mac上のコンテナから、Mac上のアプリケーションに簡単に接続する方法
Mysqlに接続する例 DSN user1:password@tcp(docker.for.mac.localhost)/database_name</description></item><item><title>echoとbase64</title><link>https://dyuji.dev/blog/memo/echo_base64/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/memo/echo_base64/</guid><description> echoコマンドはデフォルトでは改行文字が含まれるため、暗号化時などに気をつける これが原因でmysqlのdsnでエラーが発生した 改行なしオプションは-n 例
## 改行あり echo &amp;#34;hogehoge&amp;#34; | base64 &amp;gt; aG9nZWhvZ2UK ## 改行なし echo -n &amp;#34;hogehoge&amp;#34; | base64 &amp;gt; aG9nZWhvZ2U=</description></item><item><title>go testをDockerfileで実施する</title><link>https://dyuji.dev/blog/go/gotest_and_docker/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/go/gotest_and_docker/</guid><description>gorm v2がgo v1.14以降じゃないとビルドできない Jenkinsサーバーがgo v1.12でgo testのときにエラーがでる docker imageのビルドの時にgo imageでgo testがしたいができるのか? テストが落ちたらビルドも止まるか 試作コード cmd/main.go
package main import ( &amp;#34;docker-gotest/service&amp;#34; &amp;#34;fmt&amp;#34; ) func main() { _ = service.Add(1, 2) fmt.Println(&amp;#34;Hello World&amp;#34;) } service/calc.go
package service func Add(a int, b int) int { return a + b } service/calc_test.go
package service import &amp;#34;testing&amp;#34; func Test_Add(t *testing.T) { result := Add(1, 2) if result != 3 { t.Errorf(&amp;#34;Error&amp;#34;) } } Dockerfile</description></item><item><title>Golang memo</title><link>https://dyuji.dev/blog/go/golang/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/go/golang/</guid><description>Golang memo 他の言語からすると紛らわしい単語 map Goでは辞書型 interface go 環境変数の場所を間違えない 基本wslで書いて検証したとしても、vscodeの補完に使うgoのライブラリたちはwindows本体側を参照しているのでちゃんと設定する switch と select 見た目が似てるけど、違う用途
//条件分岐 switch n { case 1: fmt.Println(&amp;#34;1&amp;#34;) case 2,3: fmt.Println(&amp;#34;2 or 3&amp;#34;) default: fmt.Println(&amp;#34;other&amp;#34;) } // 条件部分を省略した書き方もできる switch { case n == 1: fmt.Println(&amp;#34;1&amp;#34;) case n == 2 || n == 3: fmt.Println(&amp;#34;2 or 3&amp;#34;) default: fmt.Println(&amp;#34;other&amp;#34;) } // channelの授受の分岐 select { case v1 := &amp;lt;-ch1: fmt.Println(v1) case v2 := &amp;lt;-ch2: fmt.</description></item><item><title>iotaとエラーハンドリング</title><link>https://dyuji.dev/blog/go/iota_and_error/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/go/iota_and_error/</guid><description>jwtのエラーを調べている時に以下のコードを見て不思議に思った
dgrijalva/jwt-go/claims.go#L38-L52
if c.VerifyExpiresAt(now, false) == false { delta := time.Unix(now, 0).Sub(time.Unix(c.ExpiresAt, 0)) vErr.Inner = fmt.Errorf(&amp;#34;token is expired by %v&amp;#34;, delta) vErr.Errors |= ValidationErrorExpired } if c.VerifyIssuedAt(now, false) == false { vErr.Inner = fmt.Errorf(&amp;#34;Token used before issued&amp;#34;) vErr.Errors |= ValidationErrorIssuedAt } if c.VerifyNotBefore(now, false) == false { vErr.Inner = fmt.Errorf(&amp;#34;token is not valid yet&amp;#34;) vErr.Errors |= ValidationErrorNotValidYet } goで|=はOR演算子を表すが、エラーでなんでOR演算子を使うのか？
dgrijalva/jwt-go/erros.goをみる</description></item><item><title>jwtの"Token used before issued" Error</title><link>https://dyuji.dev/blog/go/jwt/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/go/jwt/</guid><description>Token used before issued はjwtのParseの時iatが現在時刻より未来の場合発生する サーバー間の時刻のずれでも発生するので注意する Parseはerrroがnilでない時もtokenを返すので、後処理はできる package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/dgrijalva/jwt-go&amp;#34; ) func main() { // iatが2030年になっている tokenstring := &amp;#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxOTE2MjM5MDIyfQ.jHQiBm09vEVjEx9347u2hU7LTreUVtEbWRPWrr9DG_A&amp;#34; secret := &amp;#34;my_secret_token&amp;#34; token, err := tokenParse(tokenstring, []byte(secret)) if err != nil { fmt.Printf(&amp;#34;Error:%v\n&amp;#34;, err) return } claims, ok := token.Claims.(jwt.MapClaims) if ok { fmt.Println(claims) fmt.Println(claims[&amp;#34;name&amp;#34;]) return } } func tokenParse(idToken string, hmacSecret []byte) (*jwt.Token, error) { token, err := jwt.Parse(idToken, func(token *jwt.Token) (interface{}, error) { // アルゴリズムの判定 if _, ok := token.</description></item><item><title>mysqlのkey index</title><link>https://dyuji.dev/blog/memo/mysql_key_index/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/memo/mysql_key_index/</guid><description>describeはテーブル情報を出すが、複合キーの場合keyのカラムが1つのみmulになる indexを全て確認する際はshow indexを使う describe table_name; show index from table_name; 例
create table books(book_id int, name varchar(255), author varchar(255), publication_date datetime); mysql&amp;gt; alter table books add index book_index(name,author); mysql&amp;gt; describe books; +------------------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +------------------+--------------+------+-----+---------+-------+ | book_id | int | NO | PRI | NULL | | | name | varchar(255) | YES | MUL | NULL | | | author | varchar(255) | YES | | NULL | | | publication_date | datetime | YES | | NULL | | +------------------+--------------+------+-----+---------+-------+ 4 rows in set (0.</description></item><item><title>Terraform 勉強</title><link>https://dyuji.dev/blog/tf/gcp_tutorial_memo/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/tf/gcp_tutorial_memo/</guid><description>Terraform 勉強 Introduction to Infrastructure as Code with Terraform Infrastructure as Code(IaC)
Terraformはproviderと呼ばれるTerraformプラグインでAPIを呼び出し、インフラの操作をする
AWS GCP Azureなど有名なもののproviderは作成されている 独自でproviderを作成することも可能 providerがインフラの要素をresourceとして定義
インスタンスやネットワークなど 様々なproviderのリソースをmoduleに構成
moduleは再利用可能なTerraformの構成
Terraformは宣言型
インフラの最終状態を記述し、Terraform providerが自動で計算 Terraformでインフラ展開の流れ
Scope 適用範囲の把握 Author 構成の記述 Initialize 必要プラグインのインストール Plan 変更のプレビュー Apply 変更の実施 State file
インフラの状態を追跡するためのソース これの状態を見て、宣言した構成と合うよう変更を加える Terraform Cloud
Gitと繋いで自動的に構成の提案したり、実行環境を用意して構成変更の競合を防いだりする Install Terraform 内容をコピペして動く Quick start tutorial nginxのdocker image作成 terraform init terraform plan terraform apply terraform destroy Build Infrastructure GCPのアカウント作成</description></item><item><title>time</title><link>https://dyuji.dev/blog/go/time/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/go/time/</guid><description>time timeパッケージはデフォルトがmsなので注意する</description></item><item><title>URL Encode</title><link>https://dyuji.dev/blog/go/urlencode/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/go/urlencode/</guid><description>net/urlパッケージのURLエンコードは2種類 url.QueryEscape() スペースが+になる url.PathEscape() スペースが%20になる こちらに詳しい URI エンコーディングについて
url.EncodeではQueryEscapeの方が使われているため、URLの+を変換したいときは正規表現を用いる こちらに詳しい</description></item><item><title>WIP スタートアップ企業の業績決定要因 -質的比較分析(QCA)によるアプローチ</title><link>https://dyuji.dev/blog/memo/start_up/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/memo/start_up/</guid><description>https://www.jstage.jst.go.jp/article/keieijournal/42/0/42_40/_article/-char/ja/ 2019 年 42 巻 p. 40-51
中小企業の業績に影響を与える要因 企業家の特性 リーダーシップ 経営資源 戦略 社会的関係資本 創業者の年齢 成長指向 開業から28カ月以内のスタートアップ
質的比較分析(QCA : Qualitative Compare Analysis) *
日本政策金融公庫 政策金融機関の一つ。どちらかというと小規模な法人向けに融資する金融機関。そこに関する調査論文やデータとかも出している
政策金融機関：政府の出資による金融機関、特殊法人。政府系金融機関とも呼ばれる QCA</description></item><item><title>「超」入門 失敗の本質</title><link>https://dyuji.dev/blog/books/essence_of_failure/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/books/essence_of_failure/</guid><description> 大きな戦略における目標に寄与しない無駄な目標を実施しない 勝利の条件を理解するのは優れたリーダーに必要なこと 戦略の成功を図る指標をアップデートする 既存の指標の発見 敵対する指標の無効化 新たな指標で戦う戦う 成功体験を分析する。経験知を汎用的な指標にする 新しいルールをつくる 人・組織の柔軟な活用 新技術の開発 技術の運用方法 ダブルループ学習を心掛ける シングルループ学習 目標と問題構造を所与ないし一定とした上で最適解を探す ダブルループ学習 想定した目標と問題自体が間違っているという疑問・検討を含めた学習 現場と上層部の乖離を避ける 専門分野は専門家の知識をあげられるように リーダーが前線で直接確認することで、情報の正確さと問題解決の速度を上げる リーダーは見たくない問題を解決する覚悟の強さが要求される 正しい警告を無視しない 評価制度は組織に対するメッセージ 居心地の良い安定にならず変化できる組織 異質な情報・知識の交流 権力構造の均衡破壊 万が一の想定を持っておく</description></item><item><title>チャネルの受信とClose</title><link>https://dyuji.dev/blog/go/channel_receive/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/go/channel_receive/</guid><description> チャネルはCloseしたら0値を返すので、受信側がCloseかどうかは第二引数をとって判別する package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func A(ch chan int) { for { select { case v, ok := &amp;lt;-ch: fmt.Println(v, ok) } } } func main() { ch := make(chan int, 10) go A(ch) for i := 1; i &amp;lt;= 5; i++ { ch &amp;lt;- i } close(ch) time.Sleep(100 * time.Microsecond) } 結果
1 true
2 true
3 true
4 true
5 true
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
0 false
以下略
参考 Go の channel 処理パターン集</description></item><item><title>デバッグ</title><link>https://dyuji.dev/blog/memo/debug/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/memo/debug/</guid><description> 変更でエラーが発生するようになった時は正しく動いていたversionまで遡ってみる 大きな変更に注意する ライブラリのメジャーバージョンアップ 変更の履歴をちゃんと残す</description></item><item><title>価値観をアップデートしていくにはどうするべきか(仮)</title><link>https://dyuji.dev/blog/memo/update_values/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/memo/update_values/</guid><description>価値観をアップデートしていくにはどうするべきか(仮) 軸を増やす 未知の体験 サンプリングを変える</description></item><item><title>図解 モチベーション大百科</title><link>https://dyuji.dev/blog/books/motivation/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/books/motivation/</guid><description>目標設定のコツ 図解 モチベーション大百科より
目標を具体的な数値に変える 数値にする(割合、時刻など) 最大値、最小値の範囲で予測する 多めに目標を持つ 期待をもって行動する 運が良いと思う 学べることがあると思い行動する 締め切りは細かく区切る タスクを分解する 締め切りをつける 行動する理由を考えるより、行動のための手順を書く やることを書き出すのと、遂行することを分ける</description></item><item><title>外国語学習に成功する人，しない人 第二言語習得論への招待</title><link>https://dyuji.dev/blog/memo/foreign_language/</link><pubDate>Sun, 26 Dec 2021 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/memo/foreign_language/</guid><description>from 外国語学習に成功する人，しない人 第二言語習得論への招待
インプット 背景知識がある題材を選ぶと良い リスニングは80％くらいわかる教材を何度も聞く方がよい リスニングのスクリプトを読んで理解してから再度聞いてみる 外国語で情報を収集する ほとんどわからないものでも、聞かないより聞いた方がいい アウトプット アウトプット(話すこと、書くこと)は、毎日少しづつでもやる 話す練習はまずは意味を通じさせること、次に正しい文を意識する 話すときにコミュニケーションストラテジー(間の語)を話して時間を稼ぐ 言いたい単語が思いつかない時は別の簡単な表現で言い換える 単語の学習 文脈の中で覚える 丸暗記はなるべく避ける 知らない単語はなるべく推測する 発音・音声 難しい発音は意識しておき(lとrなど)、意識すればできるようにする 意味文法などを理解している文の音声をできるだけ正確に真似て練習する 文法 基本的なものを文をつくりアウトプットできるレベルに 説明を読んでも分からないものは無視 動機付け 高める工夫する 授業をとる、仲間とやる、好きな内容を使う、資格を受ける、外国語のことに興味を持つ</description></item><item><title>Googleドメインの設定</title><link>https://dyuji.dev/blog/memo/domain/</link><pubDate>Mon, 30 Nov 2020 11:15:29 +0900</pubDate><guid>https://dyuji.dev/blog/memo/domain/</guid><description>Google Domainにてドメインを購入しました。 購入にあたってKyashは使えませんでした。 昔、Github Pages用に作ったリポジトリを転用しています。 Githubのsettingから購入したドメインを設定し、GoogleDomain側からもレコードを設定しました。 レコードの反映は思ったより早かったです。 細かい見た目とかはおいおいやるとして、とりあえずmarkdownで記録を残そうと思います。</description></item><item><title/><link>https://dyuji.dev/blog/memo/jmeter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dyuji.dev/blog/memo/jmeter/</guid><description>Jmeter</description></item></channel></rss>