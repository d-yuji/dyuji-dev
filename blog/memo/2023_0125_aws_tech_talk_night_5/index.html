<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AWS Tech talk Night#5 | dyuji.dev</title><meta name=keywords content><meta name=description content="AWS Tech talk Night#5 クラウドネイティブ時代のエンジニアが押さえておきたい ソフトウェアの構築・運用で考慮すべき5つのポイント AWSプリンシパルエンジニアの技術記事をソリューションアーキテクトが解説

1/25にZoomウェビナーで実施された、AWSのイベント
イベントURL

概要


AWS Japan 千葉さん"><meta name=author content><link rel=canonical href=https://dyuji.dev/blog/memo/2023_0125_aws_tech_talk_night_5/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://dyuji.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dyuji.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dyuji.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dyuji.dev/apple-touch-icon.png><link rel=mask-icon href=https://dyuji.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://dyuji.dev/blog/memo/2023_0125_aws_tech_talk_night_5/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://dyuji.dev/blog/memo/2023_0125_aws_tech_talk_night_5/"><meta property="og:site_name" content="dyuji.dev"><meta property="og:title" content="AWS Tech talk Night#5"><meta property="og:description" content="AWS Tech talk Night#5 クラウドネイティブ時代のエンジニアが押さえておきたい ソフトウェアの構築・運用で考慮すべき5つのポイント AWSプリンシパルエンジニアの技術記事をソリューションアーキテクトが解説 1/25にZoomウェビナーで実施された、AWSのイベント イベントURL 概要 AWS Japan 千葉さん"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-01-25T19:00:47+09:00"><meta property="article:modified_time" content="2023-01-25T19:00:47+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="AWS Tech talk Night#5"><meta name=twitter:description content="AWS Tech talk Night#5 クラウドネイティブ時代のエンジニアが押さえておきたい ソフトウェアの構築・運用で考慮すべき5つのポイント AWSプリンシパルエンジニアの技術記事をソリューションアーキテクトが解説

1/25にZoomウェビナーで実施された、AWSのイベント
イベントURL

概要


AWS Japan 千葉さん"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://dyuji.dev/blog/"},{"@type":"ListItem","position":2,"name":"AWS Tech talk Night#5","item":"https://dyuji.dev/blog/memo/2023_0125_aws_tech_talk_night_5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AWS Tech talk Night#5","name":"AWS Tech talk Night#5","description":"AWS Tech talk Night#5 クラウドネイティブ時代のエンジニアが押さえておきたい ソフトウェアの構築・運用で考慮すべき5つのポイント AWSプリンシパルエンジニアの技術記事をソリューションアーキテクトが解説 1/25にZoomウェビナーで実施された、AWSのイベント イベントURL 概要 AWS Japan 千葉さん\n","keywords":[],"articleBody":"AWS Tech talk Night#5 クラウドネイティブ時代のエンジニアが押さえておきたい ソフトウェアの構築・運用で考慮すべき5つのポイント AWSプリンシパルエンジニアの技術記事をソリューションアーキテクトが解説 1/25にZoomウェビナーで実施された、AWSのイベント イベントURL 概要 AWS Japan 千葉さん\n概要\nAWSの最新技術やトレンド AWSのSolutionsArchitectの醍醐味 過去のセッションは動画、記事で見れる→AWS -Techplay\n今回の元ネタ→AmazonBuildersLibrary\nAWSの上位のエンジニアによって書かれた記事 日本語訳もあり それの解説 開発・運用のノウハウ サービス開発・AWS利用に役立てる 必ずしもAWSでなくてもクラウドの設計にも役に立つ\n1. キャッシングの課題と戦略 キャッシュの無批判な導入は危険 キャッシュのメリットとリスク、あるべき戦略について考える 川島さん\n得意領域 機械学習・画像処理 元記事→キャッシングの課題と戦略\nキャッシュ導入運用に考えるべき事項\nキャッシュが必要なのか キャッシュ戦略 一般的なキャッシュ運用、AWSでのキャッシュサービスについて\nネットワーク経由のデータ呼び出しで考えること\n呼び出しのレイテンシ 呼び出し量が増えたときのスケールアウト費用 ダウンストリーム(ダウンストリームリソース)\n呼び出されるコンテンツなどのこと これをキャッシュする AWSにも色々サービスがある\nキャッシュの種類2種 ローカルキャッシュ\nダウンストリームリソースに付属する インメモリキャッシュ メリット 簡単に実装できる デメリット サーバー間でキャッシュの一貫性が保証できない コールドスタート サーバー本体の負荷がかかる リクエストの合体することで緩和 ダウンストリームの負荷がサーバー群のサイズに負荷が比例する 外部キャッシュ\nダウンストリームリソースの外に存在 外部のキャッシュサーバー メリット 一貫性 コールドスタート 負荷がサーバーサイズに比例しない ストレージスペースの制約からキャッシュが解放 キャッシュを大きくできる デメリット 運用コストの増加 新たなサービスの追加 モニタリング、管理、スケーリング 運用の注意\nキャッシュ障害の対応 フェイルオーバー ローカルキャッシュとの併用 負荷制限の実装・テスト キャッシュサーバーのスケーリングと伸縮性 適切なメトリクス、閾値でスケール サーバー追加削除のテスト 複数ノードのキャッシュ書き込み トランザクションがないことに注意 他のサービスとのバージョニング 複数バージョンサービスの運用時に問題がないか アマゾンのベストプラクティス\n他のサービス同様に管理モニタリング キャッシュが使えない場合に回復できるようにする 他のサービスのバージョニングに対応できるようにする キャッシュのセキュリティ\nデータの暗号化 転送中、保管中の暗号化 キャッシュポイズニング攻撃 キャッシュに誤ったデータを参照させる 対策→ ダウンストリームプロトコルに脆弱性をなくす サイドチャネルタイミング攻撃 応答時間でキャッシュ保持の有無を判断 他のユーザーの履歴などを判断 その他キャッシュの考慮事項\nキャッシュサイズ 予想されるリクエスト量から決める 有効期限ポリシー TTL(Time to Live) 削除ポリシー LRU (least recently use) LFU (least freaquently use) メトリクスを設定してパフォーマンスを追跡し逐次改善する\nキャッシュヒット率に影響する\nthundering herd\nリソースへのリクエスト同時多発 コールドスタート時に発生しやすい →対策、リクエストの合体 キャッシュライブラリなどで実施 TTL\nソフトTTL 基本的にはこの時間まで ハードTTL 不具合があった場合代用 ネガティブキャッシュ\nエラー応答を返す キャッシュの必要性の観点\nコスト レイテンシー 可用性 2. 負荷制限を使用して過負荷を回避する 負荷制限に関してAWSが考えるベストプラクティスの共有 元記事→負荷制限を使用して過負荷を回避する\n長友さん\n概要\n一般的な負荷制限の仕組み Amazonが考えるしくみ 負荷制限とはなにか\nアムダールの法則\n理論的にシステムのスケールの限界の見積もりが可能とする法則 並列化による処理速度向上には限界がある 何％並列処理できるか？ 大量リクエストを処理する際にどうするか？\nリソースのスケール 性能向上に限界がある リトライ・バックオフ リクエストの間隔を伸ばしていく 場合によっては負荷を増大 負荷制限 リクエストの成功をへらす システムが処理する量を制御して性能の一貫性を保つ 負荷制限\n過負荷の際にリクエストのいくつかは脱落させてシステムを保護 システム全体をダウンさせずに継続を維持 パフォーマンスを維持 過負荷の状態\nスループットの状態 GoodPut スループットのうち正しく処理されたもの スループットが膨大になる → ClientTimeoutがおきる→Goodputが0になる 負荷制限で何を考慮すべきか、注意事項\nリクエストに優先順位\n優先度の低いリクエストはオフピーク時に処理する クローラの処理は優先度低 ヘルスチェックのためのロードバランサからのPingは優先度高 無駄な処理コストを使わない\n過負荷時には、レスポンスの遅さからユーザーが頻繁にリトライすることが多い 優先度の低いリクエストは削除 クロックの扱いに気をつける\n無駄な処理を避けるためにClientTimeoutに応じてサーバーは途中で処理中断 クロックをサーバー間で同期させることが重要 タイムアウトで無駄が生じる キューの扱いに注意\nリクエストがキューにされる時間が増える キューに置かれる上限時間を定めて古すぎるものは削除 成功する可能性の高い新しいリクエストを優先させる レイヤーごとに保護する\nレイヤーごとに負荷制限を実施。サービスの状況を監視 ＊どこで何が起きて負荷制限をしたのか後で追えるようにする AWSのアーキテクトが関わった負荷制限の一例\n新型コロナワクチン接種予約システム 予測困難なアクセス数をバーチャル待合室機能で対応 要件・課題 アクセス数の予測が困難 アクセス数の減少で規模を縮小できる柔軟性 CloudWatchでモニタリングしAutoScaling 3. Amazonにおけるダッシュボードのベストプラクティス ダッシュボードを作成する際のおすすめルール 元記事 → 運用を可視化するためのダッシュボードの構築\n吉澤さん\nおすすめのAWSサービス→AWS Trusted Adviser ユーザーが知りたい情報 → 数値ではなく、実際の行動や判断がほしい\nex) 天気の具体的な値より、気温に合った服装や傘が必要か知りたい ダッシュボードも同じで、目的に応じてダッシュボードを構築\nDashboarding\nダッシュボード大切 システムをリアルタイムで把握したい モニタリング 自動修復 CD いつ何がどこで起こっているのか把握できるように ダッシュボードの24hの張り付き → 人為的なエラー、見落としになるからしない\nダッシュボードのポイント\nアラームの作成 重要なモニタリングデータのアラーム→通知 迅速に判断できるように 複数種類のダッシュボード 役割・用途に応じたダッシュボード ダッシュボードの種類\n顧客志向 高レベル クライアント目線、監査人目線 具体例 カスタマーエクスペリエンスダッシュボード 健全性や外形監視、RUM 顧客影響などに答えるように システムレベルでのダッシュボード システムやエンドポイントが動作していることの確認 入出力関連 情報が増えすぎないように 低レベル 運用メンバー目線 機能にフォーカス 具体例 マイクロサービス固有のダッシュボード サービスの実装に特化 インフラストラクチャのダッシュボード 依存関係のダッシュボード 他のチームのマイクロサービスとの依存 ダッシュボードの設計\nチームに参加した人が学習しやすいように標準化をした 記事にベストプラクティスがのっている→リンク ベストプラクティスの抜粋\n最重要なデータを一番上に グラフのレイアウトは想定できる最小のディスプレイサイズに合わせる 横スクロールをなくす インシデントなど咄嗟のときに気づかない アラームを設定する場合はグラフに閾値を表示する MLの異常検知でも正常範囲を描画 各メトリクスもしくはウィジットの真の意味をユーザーが理解していることは前提にしない ウィジットの説明文を追加 システムに応じて状況に応じた複数のウィジットを用意する Get API/Put APIで場合分けすることで原因をわかりやすく 保守運用\n開発者が自分自身でアップデート 改善の実践方法 新機能をデプロイする前にダッシュボードになにか変更はありますか？と質問をはさみダッシュボードを更新する ステージングにも同様のダッシュボードを用意 ダッシュボードのレイアウトをIaCで採用、VCSで管理 障害発生後 ダッシュボードの反省 顧客影響を明確にしたか 障害原因を明確にすることに貢献したか 修復時間を短くすることの助けになったか 4. 分散システムの課題とリーダー選挙 分散システムを構築・利用する際に知っておきたいポイント 分散システム間での一貫性を保ったステート管理 参考記事 → 分散システムの課題 元記事→分散システムのリーダー選挙\n松田さん\n分散システムとは\n多数のコンピュータがネットワークで繋がり、連携して一つの作業を行うシステムのこと オフライン分散システム\n大規模計算処理を可能に コストの最適化 オンライン分散システム\n耐障害性・可用性 世界中からのアクセスのレイテンシの改善 ソフトリアルタイム 遅延が多少許される ハードリアルタイム 遅延がほぼ許されない 分散システムの課題\n悲観的な認識を持つ 分散システムは壊れる 平均故障間隔5年のコンピューター 2000台ある場合一日一台平均で壊れる 参加ノードの障害の例 リクエストが到達しない場合 リクエスト側からはレスポンスが待つがこない レスポンス前に故障 ステートを更新中に故障 →送信ノードからは故障がわからない、時間が経てば復旧するかもしれない tail latency 送信ノードはタイムアウトとして処理の終了ハンドリング 受信ノードはステートの更新処理は冪等性をもたせる レプリケーション 例：飛行機予約 予約の情報共有とレスポンス 情報共有の遅延、失敗したとき、他のノードから予約できてしまう コンフリクトが発生 対策→リーダーノード データの整合性担保をリーダーノード内で完結 各操作ごとにノードの合意を得る必要がなくなる 多数決を用いた分散システムに比べ実装が容易 AWSRDSでのレプリケーション Multi-az配置では同期レプリケーション リードレプリカでは非同期レプリケーション 分散システムにおけるリーダー選挙\nリーダーの決め方 ノードの固定 分散合意 アプリケーションの利用 lease リーダーである権利を期限付きで取得 ローカルのプロセス時間で権利を渡す 課題 処理時間の保証ができない ロッククライアントライブラリの利用 十分な期限が長くするとリースの交換に処理がとられる リーダー障害対策 冪等性担保 5. 高可用性を実現する静的安定性という考え方 クリティカルなシステムを運用する際、機能性と可用性をどのように両立させるか 『アベイラビリティゾーン』を使用し冗長化を行う際のポイント 元記事 → アベイラビリティーゾーンを使用した静的安定性\n堀さん\n高いパフォーマンス高機能高可用性を実現するのに静的安定性が必要\n依存に障害が発生しても動くように\n静的安定性とは\n障害で依存関係が損なわれてもシステムが動作し続ける性質 必要な理由\nシステムの高可用性は依存するシステムの可用性が高い必要性がある 高パフォーマンスで高機能なAWSサービスを作る上ですべての依存先の可用性を高く保つのは困難 実現するシステム\nsys1はsys2に依存 sys1はキャッシュをもって安定性を作る AWSの静的安定性\nコントロールプレーンとデータプレーンの分離 データプレーン サービスの基本機能。高い可用性、単純な依存 コントロールプレーン システムの変更 複雑な依存 ex) EC2 データプレーン ネットワーク、サーバー、ストレージ コントロールプレーン インスタンス作成、設定変更 アベイラビリティゾーン(AZ)を使用した例\nAWSサービスを使った場合の例 AWSのアベイラビリティゾーン 意味のある距離で物理的に分離 高速で暗号化されたプライベート光ファイバーネットワークで相互に接続 複数のAZにEC2を配置する ELBで分散 一般的なアーキテクチャにおける静的安定性\n→何らかの障害の際にコントロールプレーンに依存しない設計に インスタンス作成がコントロールプレーンに依存 AutoScaleでなくなる → 2つのAZインスタンスを200％用意、Autoscaleの設定は負荷テスト時の50% コスト大 → 3つのAZインスタンス150%Autoscaleの設定66.6% 障害時にインスタンス作成の必要がない。コスト低 DBを使ったアーキテクチャの静的安定性\n通常時のRDSから他のAZのスタンバイに移行する。フェイルオーバー Q\u0026A Q1 インフラとは直接関係ない質問です。\nキャッシュサーバーが含まれる構成から、データを取得する流れにについて質問です。 クライアントプログラムは、まずキャッシュ取得をトライして、 キャッシュになかったら本体からデータ取得する流れになるのでしょうか？\nデータ取得時に、キャッシュサーバーの存在を意識しないプログラムがかけると良いと思いますが、いかがでしょうか？\nA1 サイドキャッシュ ダウンストリームリソースを意識する キャッシュがなくてもアプリで対処できる 選択肢にしやすい\nインラインキャッシュ ダウンストリームリソースを意識しない バグ要因減らせる\nQ2 オンプレADと時刻同期しているサーバーと、AWSのタイムサーバーと同期しているサーバーが同一システムで動いているのですが、負荷制限をするには、やはりタイムサーバーを統一した方が良いでしょうか。\nA2 ご質問ありがとうございます。 各サーバで別々のタイムサーバを使用する状況もあるかと思いまが、AWSのタイムサーバとオンプレADでクロックがズレてしまった場合にシステムで不整合が生じてしまいます。タイムーサーバを統一した方がいいケースが多いのではないかと思います\nQ3 ダッシュボードをupdateしていく上でどのステークホルダーを重視するべきでしょうか？\nA3 ダッシュボードを作成する際には、それを使うユーザーと目的を考えながら設計していくという考え方がAmazonでは基本となっています。\nですので、ダッシュボードをupdateする際も同様で、設計する際に想定したユーザーを考えながら変更点を考えていくことになると思います。\nまた、レイアウトをIaCとしてバージョン管理することによって、場合のよってはロールバックできるようにすることも大切となります。\nQ4 データプレーン、コントロールプレーンはコンテナサービスにのみ使用する用語だと思っていました\nA4 結構色々なシステムでこの用語は使われますね！NWの世界でもNW経路制御をするところをコントロールプレーン、フレーム転送をするところをデータプレーンと呼んだりします。\nQ5 静的安定性の住所サービスの例について。 古いキャッシュを使って見かけ上動作させると、住所を更新しても新しい住所が使われず不具合になることがあると思います。 その辺りを検討した上で静的安定性を作り込むのでしょうか？\nこの例とコントロールプレーンの話は、別の話に聞こえました。\nA5 このような場合は障害発生した場合は障害発生するが、使われないようにする コントロールプレーンを時間をおく工夫\n各システムでどこが生かしつづけるシステムか、可用性を下げてもよいか、判断する。可用性とコストはトレードオフ\nQ6 EC2を用いた例をたくさん示していただきありがとうございました。現在、Fargateのみを利用しているのですが、EC2と異なり気をつけるところはありますでしょうか。特に最後のプレゼンテーションの静的可用性について、気をつけるべきことがあればぜひ教えていただきたいです。\nA6 サーバーレスやマネージドのサービスを使って静的安定性をAWS側に実施してもらう手段になる\n感想 2時間連続休憩なしのイベントだったので疲れた 登壇者が好きなAWSサービスについて述べるのはAWSっぽくて面白い AWSに限らないクラウドのアーキテクチャにまつわる話で興味深かった キャッシュにまつわる話がよかった ","wordCount":"6503","inLanguage":"ja","datePublished":"2023-01-25T19:00:47+09:00","dateModified":"2023-01-25T19:00:47+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dyuji.dev/blog/memo/2023_0125_aws_tech_talk_night_5/"},"publisher":{"@type":"Organization","name":"dyuji.dev","logo":{"@type":"ImageObject","url":"https://dyuji.dev/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TZL48NFQQ3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TZL48NFQQ3")</script></head><body id=" top"><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dyuji.dev/ accesskey=h title="dyuji.dev (Alt + H)">dyuji.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dyuji.dev/about title=about><span>about</span></a></li><li><a href=https://dyuji.dev/privacy title=privacy><span>privacy</span></a></li><li><a href=https://dyuji.dev/search title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://dyuji.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">AWS Tech talk Night#5</h1><div class=post-meta><span title='2023-01-25 19:00:47 +0900 +0900'>2023年1月25日</span></div></header><div class=post-content><h1 id=aws-tech-talk-night5-クラウドネイティブ時代のエンジニアが押さえておきたい-ソフトウェアの構築運用で考慮すべき5つのポイント-awsプリンシパルエンジニアの技術記事をソリューションアーキテクトが解説>AWS Tech talk Night#5 クラウドネイティブ時代のエンジニアが押さえておきたい ソフトウェアの構築・運用で考慮すべき5つのポイント <del>AWSプリンシパルエンジニアの技術記事をソリューションアーキテクトが解説</del><a hidden class=anchor aria-hidden=true href=#aws-tech-talk-night5-クラウドネイティブ時代のエンジニアが押さえておきたい-ソフトウェアの構築運用で考慮すべき5つのポイント-awsプリンシパルエンジニアの技術記事をソリューションアーキテクトが解説>#</a></h1><ul><li>1/25にZoomウェビナーで実施された、AWSのイベント</li><li><a href="https://techplay.jp/event/885662?utm_source=eventRemind&amp;utm_medium=email&amp;utm_campaign=tp_20230124">イベントURL</a></li></ul><h2 id=概要>概要<a hidden class=anchor aria-hidden=true href=#概要>#</a></h2><ul><li><p>AWS Japan 千葉さん</p></li><li><p>概要</p><ul><li>AWSの最新技術やトレンド</li><li>AWSのSolutionsArchitectの醍醐味</li></ul></li><li><p>過去のセッションは動画、記事で見れる→<a href=https://techplay.jp/community/aws_>AWS -Techplay</a></p></li><li><p>今回の元ネタ→<a href="https://aws.amazon.com/jp/builders-library/?cards-body.sort-by=item.additionalFields.sortDate&amp;cards-body.sort-order=desc&amp;awsf.filter-content-category=*all&amp;awsf.filter-content-type=*all&amp;awsf.filter-content-level=*all">AmazonBuildersLibrary</a></p><ul><li>AWSの上位のエンジニアによって書かれた記事</li><li>日本語訳もあり</li><li>それの解説<ul><li>開発・運用のノウハウ</li><li>サービス開発・AWS利用に役立てる</li></ul></li></ul></li><li><p>必ずしもAWSでなくてもクラウドの設計にも役に立つ</p></li></ul><h2 id=1-キャッシングの課題と戦略>1. キャッシングの課題と戦略<a hidden class=anchor aria-hidden=true href=#1-キャッシングの課題と戦略>#</a></h2><ul><li>キャッシュの無批判な導入は危険</li><li>キャッシュのメリットとリスク、あるべき戦略について考える</li></ul><ul><li><p>川島さん</p><ul><li>得意領域</li><li>機械学習・画像処理</li></ul></li><li><p>元記事→<a href="https://aws.amazon.com/jp/builders-library/caching-challenges-and-strategies/?did=ba_card&amp;trk=ba_card">キャッシングの課題と戦略</a></p></li><li><p>キャッシュ導入運用に考えるべき事項</p><ul><li>キャッシュが必要なのか</li><li>キャッシュ戦略</li></ul></li><li><p>一般的なキャッシュ運用、AWSでのキャッシュサービスについて</p></li><li><p>ネットワーク経由のデータ呼び出しで考えること</p><ul><li>呼び出しのレイテンシ</li><li>呼び出し量が増えたときのスケールアウト費用</li></ul></li><li><p>ダウンストリーム(ダウンストリームリソース)</p><ul><li>呼び出されるコンテンツなどのこと</li><li>これをキャッシュする</li></ul></li><li><p>AWSにも色々サービスがある</p></li></ul><h3 id=キャッシュの種類2種>キャッシュの種類2種<a hidden class=anchor aria-hidden=true href=#キャッシュの種類2種>#</a></h3><ul><li><p>ローカルキャッシュ</p><ul><li>ダウンストリームリソースに付属する</li><li>インメモリキャッシュ</li><li>メリット<ul><li>簡単に実装できる</li></ul></li><li>デメリット<ul><li>サーバー間でキャッシュの一貫性が保証できない</li><li>コールドスタート<ul><li>サーバー本体の負荷がかかる</li><li>リクエストの合体することで緩和</li></ul></li><li>ダウンストリームの負荷がサーバー群のサイズに負荷が比例する</li></ul></li></ul></li><li><p>外部キャッシュ</p><ul><li>ダウンストリームリソースの外に存在</li><li>外部のキャッシュサーバー</li><li>メリット<ul><li>一貫性</li><li>コールドスタート</li><li>負荷がサーバーサイズに比例しない</li><li>ストレージスペースの制約からキャッシュが解放<ul><li>キャッシュを大きくできる</li></ul></li></ul></li><li>デメリット<ul><li>運用コストの増加<ul><li>新たなサービスの追加<ul><li>モニタリング、管理、スケーリング</li></ul></li></ul></li></ul></li></ul></li><li><p>運用の注意</p><ul><li>キャッシュ障害の対応<ul><li>フェイルオーバー</li><li>ローカルキャッシュとの併用</li><li>負荷制限の実装・テスト</li></ul></li><li>キャッシュサーバーのスケーリングと伸縮性<ul><li>適切なメトリクス、閾値でスケール</li><li>サーバー追加削除のテスト</li></ul></li><li>複数ノードのキャッシュ書き込み<ul><li>トランザクションがないことに注意</li></ul></li><li>他のサービスとのバージョニング<ul><li>複数バージョンサービスの運用時に問題がないか</li></ul></li></ul></li><li><p>アマゾンのベストプラクティス</p><ul><li>他のサービス同様に管理モニタリング</li><li>キャッシュが使えない場合に回復できるようにする</li><li>他のサービスのバージョニングに対応できるようにする</li></ul></li><li><p>キャッシュのセキュリティ</p><ul><li>データの暗号化<ul><li>転送中、保管中の暗号化</li></ul></li><li>キャッシュポイズニング攻撃<ul><li>キャッシュに誤ったデータを参照させる</li><li>対策→ ダウンストリームプロトコルに脆弱性をなくす</li></ul></li><li>サイドチャネルタイミング攻撃<ul><li>応答時間でキャッシュ保持の有無を判断</li><li>他のユーザーの履歴などを判断</li></ul></li></ul></li><li><p>その他キャッシュの考慮事項</p><ul><li>キャッシュサイズ<ul><li>予想されるリクエスト量から決める</li></ul></li><li>有効期限ポリシー TTL(Time to Live)</li><li>削除ポリシー<ul><li>LRU (least recently use)</li><li>LFU (least freaquently use)</li></ul></li></ul></li><li><p>メトリクスを設定してパフォーマンスを追跡し逐次改善する</p></li><li><p>キャッシュヒット率に影響する</p></li><li><p>thundering herd</p><ul><li>リソースへのリクエスト同時多発</li><li>コールドスタート時に発生しやすい</li><li>→対策、リクエストの合体<ul><li>キャッシュライブラリなどで実施</li></ul></li></ul></li><li><p>TTL</p><ul><li>ソフトTTL<ul><li>基本的にはこの時間まで</li></ul></li><li>ハードTTL<ul><li>不具合があった場合代用</li></ul></li></ul></li><li><p>ネガティブキャッシュ</p><ul><li>エラー応答を返す</li></ul></li><li><p>キャッシュの必要性の観点</p><ul><li>コスト</li><li>レイテンシー</li><li>可用性</li></ul></li></ul><h2 id=2-負荷制限を使用して過負荷を回避する>2. 負荷制限を使用して過負荷を回避する<a hidden class=anchor aria-hidden=true href=#2-負荷制限を使用して過負荷を回避する>#</a></h2><ul><li>負荷制限に関してAWSが考えるベストプラクティスの共有</li></ul><ul><li><p>元記事→<a href="https://aws.amazon.com/jp/builders-library/using-load-shedding-to-avoid-overload/?did=ba_card&amp;trk=ba_card">負荷制限を使用して過負荷を回避する</a></p></li><li><p>長友さん</p></li><li><p>概要</p><ul><li>一般的な負荷制限の仕組み</li><li>Amazonが考えるしくみ</li></ul></li><li><p>負荷制限とはなにか</p><ul><li><p><a href=https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%A0%E3%83%80%E3%83%BC%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87>アムダールの法則</a></p><ul><li>理論的にシステムのスケールの限界の見積もりが可能とする法則</li><li>並列化による処理速度向上には限界がある</li><li>何％並列処理できるか？</li></ul></li><li><p>大量リクエストを処理する際にどうするか？</p><ul><li>リソースのスケール<ul><li>性能向上に限界がある</li></ul></li><li>リトライ・バックオフ<ul><li>リクエストの間隔を伸ばしていく</li><li>場合によっては負荷を増大</li></ul></li><li><strong>負荷制限</strong><ul><li>リクエストの成功をへらす</li><li>システムが処理する量を制御して性能の一貫性を保つ</li></ul></li></ul></li></ul></li><li><p>負荷制限</p><ul><li>過負荷の際にリクエストのいくつかは脱落させてシステムを保護</li><li>システム全体をダウンさせずに継続を維持<ul><li>パフォーマンスを維持</li></ul></li></ul></li><li><p>過負荷の状態</p><ul><li>スループットの状態</li><li>GoodPut<ul><li>スループットのうち正しく処理されたもの</li></ul></li><li>スループットが膨大になる → ClientTimeoutがおきる→Goodputが0になる</li></ul></li><li><p>負荷制限で何を考慮すべきか、注意事項</p><ul><li><p>リクエストに優先順位</p><ul><li>優先度の低いリクエストはオフピーク時に処理する<ul><li>クローラの処理は優先度低</li><li>ヘルスチェックのためのロードバランサからのPingは優先度高</li></ul></li></ul></li><li><p>無駄な処理コストを使わない</p><ul><li>過負荷時には、レスポンスの遅さからユーザーが頻繁にリトライすることが多い</li><li>優先度の低いリクエストは削除</li></ul></li><li><p>クロックの扱いに気をつける</p><ul><li>無駄な処理を避けるためにClientTimeoutに応じてサーバーは途中で処理中断</li><li>クロックをサーバー間で同期させることが重要<ul><li>タイムアウトで無駄が生じる</li></ul></li></ul></li><li><p>キューの扱いに注意</p><ul><li>リクエストがキューにされる時間が増える</li><li>キューに置かれる上限時間を定めて古すぎるものは削除<ul><li>成功する可能性の高い新しいリクエストを優先させる</li></ul></li></ul></li><li><p>レイヤーごとに保護する</p><ul><li>レイヤーごとに負荷制限を実施。サービスの状況を監視
＊どこで何が起きて負荷制限をしたのか後で追えるようにする</li></ul></li></ul></li><li><p>AWSのアーキテクトが関わった負荷制限の一例</p><ul><li>新型コロナワクチン接種予約システム<ul><li>予測困難なアクセス数をバーチャル待合室機能で対応</li></ul></li><li>要件・課題<ul><li>アクセス数の予測が困難</li><li>アクセス数の減少で規模を縮小できる柔軟性</li></ul></li><li>CloudWatchでモニタリングしAutoScaling</li></ul></li></ul><h2 id=3-amazonにおけるダッシュボードのベストプラクティス>3. Amazonにおけるダッシュボードのベストプラクティス<a hidden class=anchor aria-hidden=true href=#3-amazonにおけるダッシュボードのベストプラクティス>#</a></h2><ul><li>ダッシュボードを作成する際のおすすめルール</li></ul><ul><li><p>元記事 → <a href=https://aws.amazon.com/jp/builders-library/building-dashboards-for-operational-visibility/>運用を可視化するためのダッシュボードの構築</a></p></li><li><p>吉澤さん</p><ul><li>おすすめのAWSサービス→<a href=https://aws.amazon.com/jp/premiumsupport/technology/trusted-advisor/>AWS Trusted Adviser</a></li></ul></li><li><p>ユーザーが知りたい情報 → 数値ではなく、実際の行動や判断がほしい</p><ul><li>ex) 天気の具体的な値より、気温に合った服装や傘が必要か知りたい</li></ul></li><li><p>ダッシュボードも同じで、目的に応じてダッシュボードを構築</p></li><li><p>Dashboarding</p><ul><li>ダッシュボード大切</li><li>システムをリアルタイムで把握したい<ul><li>モニタリング</li><li>自動修復</li><li>CD</li></ul></li><li>いつ何がどこで起こっているのか把握できるように</li></ul></li><li><p>ダッシュボードの24hの張り付き → 人為的なエラー、見落としになるからしない</p></li><li><p>ダッシュボードのポイント</p><ul><li>アラームの作成<ul><li>重要なモニタリングデータのアラーム→通知</li><li>迅速に判断できるように</li></ul></li><li>複数種類のダッシュボード<ul><li>役割・用途に応じたダッシュボード</li></ul></li></ul></li><li><p>ダッシュボードの種類</p><ul><li>顧客志向<ul><li>高レベル<ul><li>クライアント目線、監査人目線</li></ul></li><li>具体例<ul><li>カスタマーエクスペリエンスダッシュボード<ul><li>健全性や外形監視、RUM</li><li>顧客影響などに答えるように</li></ul></li><li>システムレベルでのダッシュボード<ul><li>システムやエンドポイントが動作していることの確認<ul><li>入出力関連</li></ul></li></ul></li><li>情報が増えすぎないように</li></ul></li><li>低レベル<ul><li>運用メンバー目線</li><li>機能にフォーカス</li></ul></li><li>具体例<ul><li>マイクロサービス固有のダッシュボード<ul><li>サービスの実装に特化</li></ul></li><li>インフラストラクチャのダッシュボード</li><li>依存関係のダッシュボード<ul><li>他のチームのマイクロサービスとの依存</li></ul></li></ul></li></ul></li></ul></li><li><p>ダッシュボードの設計</p><ul><li>チームに参加した人が学習しやすいように標準化をした</li><li>記事にベストプラクティスがのっている→<a href=https://aws.amazon.com/jp/builders-library/building-dashboards-for-operational-visibility/#Dashboard_design>リンク</a></li></ul></li><li><p>ベストプラクティスの抜粋</p><ol><li>最重要なデータを一番上に</li><li>グラフのレイアウトは想定できる最小のディスプレイサイズに合わせる<ul><li>横スクロールをなくす<ul><li>インシデントなど咄嗟のときに気づかない</li></ul></li></ul></li><li>アラームを設定する場合はグラフに閾値を表示する<ul><li>MLの異常検知でも正常範囲を描画</li></ul></li><li>各メトリクスもしくはウィジットの真の意味をユーザーが理解していることは前提にしない<ul><li>ウィジットの説明文を追加</li></ul></li><li>システムに応じて状況に応じた複数のウィジットを用意する<ul><li>Get API/Put APIで場合分けすることで原因をわかりやすく</li></ul></li></ol></li><li><p>保守運用</p><ul><li>開発者が自分自身でアップデート</li><li>改善の実践方法<ul><li>新機能をデプロイする前にダッシュボードになにか変更はありますか？と質問をはさみダッシュボードを更新する<ul><li>ステージングにも同様のダッシュボードを用意</li><li>ダッシュボードのレイアウトをIaCで採用、VCSで管理</li></ul></li><li>障害発生後<ul><li>ダッシュボードの反省<ul><li>顧客影響を明確にしたか</li><li>障害原因を明確にすることに貢献したか</li><li>修復時間を短くすることの助けになったか</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id=4-分散システムの課題とリーダー選挙>4. 分散システムの課題とリーダー選挙<a hidden class=anchor aria-hidden=true href=#4-分散システムの課題とリーダー選挙>#</a></h2><ul><li>分散システムを構築・利用する際に知っておきたいポイント</li><li>分散システム間での一貫性を保ったステート管理</li><li>参考記事 → <a href=https://aws.amazon.com/jp/builders-library/challenges-with-distributed-systems/>分散システムの課題</a></li></ul><ul><li><p>元記事→<a href="https://aws.amazon.com/jp/builders-library/leader-election-in-distributed-systems/?nc1=h_ls">分散システムのリーダー選挙</a></p></li><li><p>松田さん</p></li><li><p>分散システムとは</p><ul><li>多数のコンピュータがネットワークで繋がり、連携して一つの作業を行うシステムのこと</li></ul></li><li><p>オフライン分散システム</p><ul><li>大規模計算処理を可能に</li><li>コストの最適化</li></ul></li><li><p>オンライン分散システム</p><ul><li>耐障害性・可用性</li><li>世界中からのアクセスのレイテンシの改善</li><li>ソフトリアルタイム<ul><li>遅延が多少許される</li></ul></li><li>ハードリアルタイム<ul><li>遅延がほぼ許されない</li></ul></li></ul></li><li><p>分散システムの課題</p><ul><li>悲観的な認識を持つ<ul><li>分散システムは壊れる<ul><li>平均故障間隔5年のコンピューター</li><li>2000台ある場合一日一台平均で壊れる</li></ul></li><li>参加ノードの障害の例<ul><li>リクエストが到達しない場合<ul><li>リクエスト側からはレスポンスが待つがこない</li></ul></li><li>レスポンス前に故障</li><li>ステートを更新中に故障</li><li>→送信ノードからは故障がわからない、時間が経てば復旧するかもしれない tail latency</li></ul></li><li>送信ノードはタイムアウトとして処理の終了ハンドリング</li><li>受信ノードはステートの更新処理は冪等性をもたせる</li></ul></li><li>レプリケーション<ul><li>例：飛行機予約<ul><li>予約の情報共有とレスポンス</li><li>情報共有の遅延、失敗したとき、他のノードから予約できてしまう</li><li>コンフリクトが発生</li></ul></li></ul></li><li>対策→リーダーノード<ul><li>データの整合性担保をリーダーノード内で完結</li><li>各操作ごとにノードの合意を得る必要がなくなる</li><li>多数決を用いた分散システムに比べ実装が容易</li></ul></li><li>AWSRDSでのレプリケーション<ul><li>Multi-az配置では同期レプリケーション</li><li>リードレプリカでは非同期レプリケーション</li></ul></li></ul></li><li><p>分散システムにおけるリーダー選挙</p><ul><li>リーダーの決め方<ul><li>ノードの固定</li><li>分散合意</li><li>アプリケーションの利用</li><li>lease<ul><li>リーダーである権利を期限付きで取得</li><li>ローカルのプロセス時間で権利を渡す</li><li>課題<ul><li>処理時間の保証ができない<ul><li>ロッククライアントライブラリの利用</li></ul></li><li>十分な期限が長くするとリースの交換に処理がとられる</li></ul></li></ul></li></ul></li><li>リーダー障害対策<ul><li>冪等性担保</li></ul></li></ul></li></ul><h2 id=5-高可用性を実現する静的安定性という考え方>5. 高可用性を実現する静的安定性という考え方<a hidden class=anchor aria-hidden=true href=#5-高可用性を実現する静的安定性という考え方>#</a></h2><ul><li>クリティカルなシステムを運用する際、機能性と可用性をどのように両立させるか</li><li>『アベイラビリティゾーン』を使用し冗長化を行う際のポイント</li></ul><ul><li><p>元記事 → <a href="https://aws.amazon.com/jp/builders-library/static-stability-using-availability-zones/?did=ba_card&amp;trk=ba_card">アベイラビリティーゾーンを使用した静的安定性</a></p></li><li><p>堀さん</p></li><li><p>高いパフォーマンス高機能高可用性を実現するのに静的安定性が必要</p></li><li><p>依存に障害が発生しても動くように</p></li><li><p>静的安定性とは</p><ul><li>障害で依存関係が損なわれてもシステムが動作し続ける性質</li></ul></li><li><p>必要な理由</p><ul><li>システムの高可用性は依存するシステムの可用性が高い必要性がある</li><li>高パフォーマンスで高機能なAWSサービスを作る上ですべての依存先の可用性を高く保つのは困難</li></ul></li><li><p>実現するシステム</p><ul><li>sys1はsys2に依存</li><li>sys1はキャッシュをもって安定性を作る</li></ul></li><li><p>AWSの静的安定性</p><ul><li>コントロールプレーンとデータプレーンの分離<ul><li>データプレーン<ul><li>サービスの基本機能。高い可用性、単純な依存</li></ul></li><li>コントロールプレーン<ul><li>システムの変更</li><li>複雑な依存</li></ul></li></ul></li><li>ex) EC2<ul><li>データプレーン<ul><li>ネットワーク、サーバー、ストレージ</li></ul></li><li>コントロールプレーン<ul><li>インスタンス作成、設定変更</li></ul></li></ul></li></ul></li><li><p>アベイラビリティゾーン(AZ)を使用した例</p><ul><li>AWSサービスを使った場合の例</li><li>AWSのアベイラビリティゾーン<ul><li>意味のある距離で物理的に分離</li><li>高速で暗号化されたプライベート光ファイバーネットワークで相互に接続</li><li>複数のAZにEC2を配置する</li><li>ELBで分散</li></ul></li></ul></li><li><p>一般的なアーキテクチャにおける静的安定性</p><ul><li>→何らかの障害の際にコントロールプレーンに依存しない設計に
インスタンス作成がコントロールプレーンに依存</li><li>AutoScaleでなくなる</li><li>→ 2つのAZインスタンスを200％用意、Autoscaleの設定は負荷テスト時の50%
コスト大</li><li>→ 3つのAZインスタンス150%Autoscaleの設定66.6%
障害時にインスタンス作成の必要がない。コスト低</li></ul></li><li><p>DBを使ったアーキテクチャの静的安定性</p><ul><li>通常時のRDSから他のAZのスタンバイに移行する。フェイルオーバー</li></ul></li></ul><h2 id=qa>Q&amp;A<a hidden class=anchor aria-hidden=true href=#qa>#</a></h2><h3 id=q1>Q1<a hidden class=anchor aria-hidden=true href=#q1>#</a></h3><p>インフラとは直接関係ない質問です。</p><p>キャッシュサーバーが含まれる構成から、データを取得する流れにについて質問です。
クライアントプログラムは、まずキャッシュ取得をトライして、
キャッシュになかったら本体からデータ取得する流れになるのでしょうか？</p><p>データ取得時に、キャッシュサーバーの存在を意識しないプログラムがかけると良いと思いますが、いかがでしょうか？</p><h3 id=a1>A1<a hidden class=anchor aria-hidden=true href=#a1>#</a></h3><p>サイドキャッシュ ダウンストリームリソースを意識する
キャッシュがなくてもアプリで対処できる
選択肢にしやすい</p><p>インラインキャッシュ ダウンストリームリソースを意識しない
バグ要因減らせる</p><h3 id=q2>Q2<a hidden class=anchor aria-hidden=true href=#q2>#</a></h3><p>オンプレADと時刻同期しているサーバーと、AWSのタイムサーバーと同期しているサーバーが同一システムで動いているのですが、負荷制限をするには、やはりタイムサーバーを統一した方が良いでしょうか。</p><h3 id=a2>A2<a hidden class=anchor aria-hidden=true href=#a2>#</a></h3><p>ご質問ありがとうございます。
各サーバで別々のタイムサーバを使用する状況もあるかと思いまが、AWSのタイムサーバとオンプレADでクロックがズレてしまった場合にシステムで不整合が生じてしまいます。タイムーサーバを統一した方がいいケースが多いのではないかと思います</p><h3 id=q3>Q3<a hidden class=anchor aria-hidden=true href=#q3>#</a></h3><p>ダッシュボードをupdateしていく上でどのステークホルダーを重視するべきでしょうか？</p><h2 id=a3>A3<a hidden class=anchor aria-hidden=true href=#a3>#</a></h2><p>ダッシュボードを作成する際には、それを使うユーザーと目的を考えながら設計していくという考え方がAmazonでは基本となっています。</p><p>ですので、ダッシュボードをupdateする際も同様で、設計する際に想定したユーザーを考えながら変更点を考えていくことになると思います。</p><p>また、レイアウトをIaCとしてバージョン管理することによって、場合のよってはロールバックできるようにすることも大切となります。</p><h3 id=q4>Q4<a hidden class=anchor aria-hidden=true href=#q4>#</a></h3><p>データプレーン、コントロールプレーンはコンテナサービスにのみ使用する用語だと思っていました</p><h3 id=a4>A4<a hidden class=anchor aria-hidden=true href=#a4>#</a></h3><p>結構色々なシステムでこの用語は使われますね！NWの世界でもNW経路制御をするところをコントロールプレーン、フレーム転送をするところをデータプレーンと呼んだりします。</p><h3 id=q5>Q5<a hidden class=anchor aria-hidden=true href=#q5>#</a></h3><p>静的安定性の住所サービスの例について。
古いキャッシュを使って見かけ上動作させると、住所を更新しても新しい住所が使われず不具合になることがあると思います。
その辺りを検討した上で静的安定性を作り込むのでしょうか？</p><p>この例とコントロールプレーンの話は、別の話に聞こえました。</p><h3 id=a5>A5<a hidden class=anchor aria-hidden=true href=#a5>#</a></h3><p>このような場合は障害発生した場合は障害発生するが、使われないようにする
コントロールプレーンを時間をおく工夫</p><p>各システムでどこが生かしつづけるシステムか、可用性を下げてもよいか、判断する。可用性とコストはトレードオフ</p><h3 id=q6>Q6<a hidden class=anchor aria-hidden=true href=#q6>#</a></h3><p>EC2を用いた例をたくさん示していただきありがとうございました。現在、Fargateのみを利用しているのですが、EC2と異なり気をつけるところはありますでしょうか。特に最後のプレゼンテーションの静的可用性について、気をつけるべきことがあればぜひ教えていただきたいです。</p><h3 id=a6>A6<a hidden class=anchor aria-hidden=true href=#a6>#</a></h3><p>サーバーレスやマネージドのサービスを使って静的安定性をAWS側に実施してもらう手段になる</p><h2 id=感想>感想<a hidden class=anchor aria-hidden=true href=#感想>#</a></h2><ul><li>2時間連続休憩なしのイベントだったので疲れた</li><li>登壇者が好きなAWSサービスについて述べるのはAWSっぽくて面白い</li><li>AWSに限らないクラウドのアーキテクチャにまつわる話で興味深かった<ul><li>キャッシュにまつわる話がよかった</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dyuji.dev/>dyuji.dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>