---
title: "Golang Tokyo #41 参加メモ"
date: 2025-10-02T15:15:00+09:00
tags: [Go]

---


# golang.tokyo #41

* Goコミュニティの技術談義
* 今回はGMOベパポ主催
* [イベントURL](https://golangtokyo.connpass.com/event/366620/)

## LT1 Go Embedでwasm埋め込み

<script async class="docswell-embed" src="https://www.docswell.com/assets/libs/docswell-embed/docswell-embed.min.js" data-src="https://www.docswell.com/slide/KLV6VQ/embed" data-aspect="0.5625"></script><div class="docswell-link"><a href="https://www.docswell.com/s/7328957/KLV6VQ-2025-09-30-073314">Go Embedでwasm埋め込み by @7328957</a></div>


* 竹田さん
* 株式会社ラクス
  * 今回のテーマは仕事関係ない話

* go embed
  * いろんなファイルを埋め込み可能にするパッケージ
    * テキストファイル、バイナリファイルなど
* ファイルにコメント
* ファイルの埋め込みはコンパイル時に実行
    * [参考](https://future-architect.github.io/articles/20210208/)


* wasmはどう埋め込むか？
    * 他の同様にファイルの中にコメント
    * []byteの変数として読み込む

* **goで作ったわけではないwasmでも呼び出せる**
    * goroutineで呼び出しもできる

* wasm埋め込みのメリット
    * Goバイナリで完結
    * wasmランタイムも埋め込める
    * ビルド時に埋め込めるので安全
    * ライブラリとして意識せずに使える
    g* oの機能も使える

### Q&A
* Q. ユースケースはどんなものがあるか？ wasmにコンパイルできれば、goで任意のコードが呼び出せるか？
* A. cgoでなくwasmでインポートできるとか、任意のコードは呼び出せると思う

## LT2 Goクイズ
* jumpaku

* クイズ5問
* 選択肢式

* Q1 実行時エラーマップのキーがないとこ？
  * A コンパイルエラー。mapに対する添字アクセスはアドレッサブルでない

* Q2 実行時エラーnil pointer？
    * A Xを出力。メソッド内tを参照しないためnil pointerは発生しない

* Q3 実行時エラーnil pointer
    * A 実行時エラー。値のデリファレンス時にエラー

* Q4 X出力。
  * A Xを出力tはアドレッサブル

* Q5 X出力
    * A コンパイルエラー。コンポジットリテラルはアドレッサブルでない

* 振る舞いに注意
    * ポインタ、レシーバ
    * アドレッサブルな値
    * コンポジットリテラルは例外

## LT3 自作LLM Native GORM Pluginで実現するAI Agentバックテスト基盤構築

<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/70a1bae7b4dc4c5886f57353b8f7a9bc" title="自作LLM Native GORM Pluginで実現する AI Agentバックテスト基盤構築" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>

* LayerX pon

* AI申請レビュー
    * AI機能をめっちゃつくっている

* AIAgentのバックテスト
    * **バックテスト**：金融取引戦略やシステムが過去のデータを元にどの程度パフォーマンスを出すか評価するテスト
    * 評価捗る
    * 提案に使える
    * 機能の効果をチェックできる

* 過去データsnowflakeに保存している
    * **snowflake**：クラウドデータウェアハウス。TreasureDataとかと一緒
    * プロシージャで取り出し
      * 複数の手続きクエリをまとめたもの

* 課題：AI申請レビューはAPIに依存
    * APIは最新データに依存
    * snowflakeでの機能差し替えは難しい
    * APIの参照先をsnowflakeに差し替え→クエリビルダーから影響してしまう

* APIの実装を変更しないでやる→gorm pluginを使う
    * 任意の処理を差し込める
    * プラグインを作った
    * LLMでSQLを書き換え
        * パフォーマンスが必要でないからLLMを利用可能なケース
        * バッチ処理
* APIでgorm v1/v2が混在
    * 移行用のパッケージ
    * ゴールデンテストを作成
    * →バックテストできた

* **gorm pluginが手段の選択肢にあると便利**


## LT4 KessokuのDIにおけるgoroutineスケジューリング

<iframe class="speakerdeck-iframe" frameborder="0" src="https://speakerdeck.com/player/affeef4b70904048b8a450761b706630" title="KessokuのDIにおけるgoroutineスケジューリング / golang.tokyo #41" allowfullscreen="true" style="border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 100%; height: auto; aspect-ratio: 560 / 315;" data-ratio="1.7777777777777777"></iframe>


* マズリーンさん
  * SRE Dena

* DIツールkessokuの話

* GoのDI
    * DIとは依存を外部から注入する設計パターン
    * ツール・ライブラリで自動化可能
        * [google/wire](https://github.com/google/wire)
            * 実行時オーバーヘッドがない
            * コンパイルエラーでミスがわかる
            * **リポジトリアーカイブされてしまった**
* 課題
    * 開発体験が悪い
      * 補完が効かない
    * goroutineが使えない
* →ライブラリ作成 [kessoku](https://github.com/mazrean/kessoku)
* wireとほぼ同じ/Buildタグ不要
* asyncの設定→goroutineで非同期に
    * →コールドスタートが高速化

* goroutineのスケジューリング(本題)
    * 最小限のgoroutineで非同期にしたい←大変
    * DI→依存関係をグラフ化→トポロジカルソートで一列に並べる(wire)
    * 要件
        * 依存関係のないasyncは別goroutine
        * 最小限のgoroutine
            * 必須ではない
        * asyncなしはwireと同じ
* やったこと
    * goroutineの数を導出
        * 最大非同期数
            * asyncは考慮しないゆるい制約
            * グラフ理論最小パス
                * 最大マッチング問題
    * 実行goroutineを決定
        * asyncとasyncそれぞれ優先度で設定

## LT5 Goで時間を“操る”テスト, synctest
* 26新卒
* LayerXでインターン

* go1.25で追加されたtesting/synctestについて使ってみた

* メリット
    * goの並行処理は直感的にかける
* デメリット
    * 非決定的、time.sleepでCIが遅くなる

* synctest
    * バブルをつくって実行
        * Test() 隔離環境で実行
        * Wait() 現在のバブルのすべてのgoroutineがdurably blockedになるまで待機

* ユースケース
    * IOの疑似検証
    * Context timeout
    * TTLキャッシュ
    * 並行パイプライン


## Goにおける生成AIによるコード生成のベンチマーク評価入門
* どすこい
* FY24卒
* 武田
    * バックエンド開発のWebエンジニア GMOペパボ

* AIコーディングの精度について
  * Goはシンプルだから精度高い？→調べると低いらしい
  * コードの生成の評価って何をしているのか？
  * 精度評価は業務と同じといえるのか？
    * (定性評価・試行錯誤も大事)

* 定量評価のデータセット
  * [HumanEval](https://github.com/openai/human-eval)
    * 人間が書いたコード
    * Githubそのままではいけないケースを用意
    * Python
  * [HumanEval-XL](https://github.com/FloatAI/humaneval-xl)
    * 複数言語の比較
    * LLMで翻訳

* 評価方法
    * pass@k
        * k=1 一発勝負
        * k=100 100回施行、理論的助言
        * k=5~10 施行した使い心地

* データセットの入力
    * json
        * プロンプトなど
    * 簡単な問題から、高難易度まで
* テストケースの例
  * 残高管理問題
      * 入力を入れていくときにマイナスになるか
  * 範囲偶数問題
      * 範囲の偶数を返す

* 他の言語に比べGoが低い理由
    * 正解の為のコードが長くなりやすい→失敗が多い？
    * テストの性質
        * テストケースは小規模アルゴリズムパズルで、APIなどGoが得意な分野がテストされてない

## 感想
* 自前でpluginやライブラリを作る選択肢を持ちたい
  * 期限が差し迫ったタスクだと、見込みが立ちやすい選択肢取りがち
* AIのコード生成でGoの精度が高くないの以外だった
